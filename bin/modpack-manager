#!/usr/bin/env python3
"""
Modpack Manager - Manage mods, generate modpacks, and create wiki pages.

This script loads a virtual environment from bin/venv and runs the mpmanager
package.
"""

import os
import sys
import shutil
import subprocess
import tempfile
from pathlib import Path

# Get the script directory (bin/)
SCRIPT_DIR = Path(__file__).resolve().parent
REPO_ROOT = SCRIPT_DIR.parent

# Check if this is a pytest command - bypass all setup
if len(sys.argv) > 1 and sys.argv[1] == "pytest":
    # Run pytest in a temporary test virtual environment
    TEST_VENV_DIR = SCRIPT_DIR / ".test-venv"
    requirements_file = SCRIPT_DIR / "requirements.txt"
    tests_dir = SCRIPT_DIR / "tests"
    
    try:
        # Create test virtual environment
        print("Creating test virtual environment...")
        result = subprocess.run(
            [sys.executable, "-m", "venv", str(TEST_VENV_DIR)],
            cwd=str(SCRIPT_DIR),
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            print(f"Error creating test virtual environment: {result.stderr}", file=sys.stderr)
            sys.exit(1)
        
        # Install dependencies
        test_venv_pip = TEST_VENV_DIR / "bin" / "pip"
        if requirements_file.exists():
            print("Installing test dependencies...")
            result = subprocess.run(
                [str(test_venv_pip), "install", "-r", str(requirements_file)],
                cwd=str(SCRIPT_DIR),
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                print(f"Error installing dependencies: {result.stderr}", file=sys.stderr)
                sys.exit(1)
        
        # Run pytest
        test_venv_python = TEST_VENV_DIR / "bin" / "python"
        pytest_args = sys.argv[2:] if len(sys.argv) > 2 else []
        
        # Change to repo root for pytest
        result = subprocess.run(
            [str(test_venv_python), "-m", "pytest", str(tests_dir)] + pytest_args,
            cwd=str(REPO_ROOT),
        )
        
        exit_code = result.returncode
        
    finally:
        # Clean up test virtual environment
        if TEST_VENV_DIR.exists():
            print("Cleaning up test virtual environment...")
            shutil.rmtree(TEST_VENV_DIR)
    
    sys.exit(exit_code)

# Add bin/mpmanager to Python path
MPMANAGER_DIR = SCRIPT_DIR / "mpmanager"
sys.path.insert(0, str(MPMANAGER_DIR))

# Create venv if it doesn't exist
VENV_DIR = SCRIPT_DIR / "venv"
if not VENV_DIR.exists():
    print("Creating virtual environment...")
    import subprocess
    result = subprocess.run(
        [sys.executable, "-m", "venv", str(VENV_DIR)],
        cwd=str(SCRIPT_DIR),
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"Error creating virtual environment: {result.stderr}", file=sys.stderr)
        sys.exit(1)
    
    # Install dependencies
    venv_pip = VENV_DIR / "bin" / "pip"
    requirements_file = SCRIPT_DIR / "requirements.txt"
    if requirements_file.exists():
        print("Installing dependencies...")
        result = subprocess.run(
            [str(venv_pip), "install", "-r", str(requirements_file)],
            cwd=str(SCRIPT_DIR),
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            print(f"Error installing dependencies: {result.stderr}", file=sys.stderr)
            sys.exit(1)
    print("Virtual environment created and dependencies installed.")

# Use venv if we're not already using it
if sys.executable != str(VENV_DIR / "bin" / "python"):
    venv_python = VENV_DIR / "bin" / "python"
    if venv_python.exists():
        # Use venv Python if available
        os.execv(str(venv_python), [str(venv_python)] + sys.argv)

# Check for missing dependencies and install them
def parse_requirements_file(requirements_file):
    """Parse requirements.txt and extract module names.
    
    Returns a list of (package_name, import_name) tuples.
    Maps package names to their import names (e.g., pyyaml -> yaml).
    """
    import re
    
    # Map package names to their import names
    # Some packages have different names when installed vs imported
    package_to_import = {
        "pyyaml": "yaml",
        # Add more mappings as needed
    }
    
    modules = []
    if not requirements_file.exists():
        return modules
    
    with open(requirements_file, "r") as f:
        for line in f:
            line = line.strip()
            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue
            
            # Remove version specifiers, extras, and other pip options
            # Examples: "package>=1.0", "package[extra]", "package==1.0.0"
            # Extract just the base package name
            package_name = re.split(r"[>=<\[\]!@#]", line)[0].strip()
            
            if package_name:
                # Map to import name if needed, otherwise use package name
                import_name = package_to_import.get(package_name, package_name)
                modules.append((package_name, import_name))
    
    return modules


def check_and_install_dependencies():
    """Check for required dependencies and install if missing.
    
    Reads requirements.txt to determine which modules to check.
    """
    requirements_file = SCRIPT_DIR / "requirements.txt"
    
    if not requirements_file.exists():
        print("Warning: requirements.txt not found, skipping dependency check", file=sys.stderr)
        return
    
    # Parse requirements file to get modules to check
    required_modules = parse_requirements_file(requirements_file)
    
    if not required_modules:
        return
    
    # Check for missing modules
    missing_modules = []
    for package_name, import_name in required_modules:
        try:
            __import__(import_name)
        except ImportError:
            missing_modules.append((package_name, import_name))
    
    if missing_modules:
        missing_packages = [pkg for pkg, _ in missing_modules]
        print(f"Missing dependencies detected: {', '.join(missing_packages)}")
        print("Installing/updating dependencies...")
        
        import subprocess
        venv_pip = VENV_DIR / "bin" / "pip"
        
        if not venv_pip.exists():
            print("Error: pip not found in virtual environment", file=sys.stderr)
            sys.exit(1)
        
        # Install/upgrade dependencies
        result = subprocess.run(
            [str(venv_pip), "install", "-r", str(requirements_file), "--upgrade"],
            cwd=str(SCRIPT_DIR),
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"Error installing dependencies: {result.stderr}", file=sys.stderr)
            sys.exit(1)
        
        print("Dependencies installed successfully.")
        
        # Verify all modules are now available
        still_missing = []
        for package_name, import_name in required_modules:
            try:
                __import__(import_name)
            except ImportError:
                still_missing.append(package_name)
        
        if still_missing:
            print(f"Error: Still missing dependencies after installation: {', '.join(still_missing)}", file=sys.stderr)
            sys.exit(1)

# Check dependencies before importing mpmanager
check_and_install_dependencies()

# Import and run the CLI
from mpmanager.cli import main

if __name__ == "__main__":
    sys.exit(main())
